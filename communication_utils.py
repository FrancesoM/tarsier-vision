####### DESIGN PATTERNS ####################################################################

# This is an attempt to abstract the communication abilities of the tarsier-job script
# the idea is that now we talk through telegram but it doesn't HAVE to be the only option
# it was just the most convenient. 

# To abstract it we need to define a set of operations that we need to support, in particular:
# - send text
# - send message 
# - send image 
# - poll for commands and respond to them 

# The user would then create an object CommHandler and attach a backend for instance TG 
# however for now I will make a hardcoded Telegram implementation, while keeping the functions
# general enough so if I make them more generic in the future the tarsier-job.py won't change. 

####### SECURITY CONCERNS ####################################################################

# The way telegram works is that the bot is accessible by anyone and we don't want to send 
# the videos to a random person that queries them, I made a quick assessment of the security 
# implications of this approach and I deem it safe. Here is a quick summary: 

# The primary conclusion was that the Telegram server handles a significant amount of the 
# security work for you. It sanitizes the incoming requests, so common vulnerabilities like 
# malicious JSON payloads or direct attempts to exploit server-side libraries like curl or 
# requests via the API's structure are not a significant concern. 
# The server acts as a strong barrier, only forwarding valid, structured data to your bot.

# The main point of vulnerability is in the user-provided text field, as this is the only 
# part of the message that Telegram passes to your bot unchanged. The danger isn't from the 
# Telegram platform itself, but from how your bot's code processes that text. 
# For example, if your bot takes the user's message and directly executes it as a shell command, 
# or uses it to build a database query without proper sanitization, that's where an attacker 
# can exploit a vulnerability.

# Therefore, the key to a secure bot is to assume that all user input in the text field is 
# potentially malicious. The best defense is to implement robust validation and sanitization 
# on your end before you use the text for any purpose.

# To avoid bad texts we can filter from chat id and user id, which are whitelisted numbers from 
# my and other allowed telegram groups and accounts. The assumption here is that a malicious user 
# cannot spoof these IDs because they are generated by the telegram server. 

######### THREAD SAFETY CONCERNS ###########################################################

# This library only contains functions and it's stateless so it doesn't really matter if the
# functions are called from multiple threads. Actually there is one element that keeps a state
# which is the file that keeps the last id for the updates. I can add a TODO to have a lock on 
# this file although it doesn't make much sense that multiple threads call the wait_command. 



import os
import pathlib
from pathlib import Path
import requests
from urllib.parse import quote
from datetime import datetime
import logging
import time

# Wokaround so that this stateless module uses the same logger as the main function that imports this 
# module. 
logger = logging.getLogger('shared_logger')

TG_TOKEN = os.getenv("TG_TOKEN")  # token from env

# The base URL for the Telegram Bot API
API_URL = f"https://api.telegram.org/bot{TG_TOKEN}/"

#When parsing the request, allow only if it comes from the whitelist
WL_CHAT_ID = os.getenv("WL_CHAT_ID", "").split(",")  # allow multiple IDs, comma separated
WL_USER_ID = os.getenv("WL_USER_ID", "").split(",")  # allow multiple IDs, comma separated

# When sending a message, send it only to a specific chat defined by another env variable
SEND_CHAT_ID  = os.getenv("SEND_CHAT_ID")
DEBUG_CHAT_ID = os.getenv("DEBUG_CHAT_ID")

# To survive reboots/crashes we need to keep track of the last offset since we polled 
# we therefore need to save it to a file
# File to store the last processed update ID
# NOTE: This env variable should map to a location that is persistent in the container, else it's lost 
# when the container image is deleted. 
LAST_UPDATE_ID_PATH = Path(os.getenv("LAST_UPDATE_ID_PATH"))

def read_last_update_id() -> int:
    """Reads the last processed update ID from a file using pathlib."""
    # Check if the file exists before attempting to read.
    logger.info(f"CIAOOOOO")
    if LAST_UPDATE_ID_PATH.exists():
        content = LAST_UPDATE_ID_PATH.read_text().strip()
        logger.error(f"File {LAST_UPDATE_ID_PATH} exists, reading it")
        return int(content) if content else 0
    else:
        logger.error(f"File {LAST_UPDATE_ID_PATH} doesn't exists, writing it")
        write_last_update_id(-1)
        return -1

def write_last_update_id(update_id: int) -> None:
    """Writes the last processed update ID to a file using pathlib."""
    logger.info(f"File {LAST_UPDATE_ID_PATH} writing it")
    try:
        # Create the parent directory if it doesn't exist.
        LAST_UPDATE_ID_PATH.parent.mkdir(parents=True, exist_ok=True)
        LAST_UPDATE_ID_PATH.write_text(str(update_id))
    except Exception as e:
        logger.error(f"Failed to write last_update_id to file: {e}")

def send_text(text: str) -> None:
    """
    Sends a text message to the configured chat ID.
    """
    params = {"chat_id": SEND_CHAT_ID, "text": text}
    try:
        response = requests.post(API_URL + "sendMessage", data=params)
        response.raise_for_status()
        logger.info(f"Sent text message to {SEND_CHAT_ID}")
    except requests.exceptions.RequestException as e:
        logger.error(f"Error sending text message to {SEND_CHAT_ID}: {e}")

def send_photo(image_path: Path, caption: str = "") -> None:
    """
    Sends a photo from a local file to the configured chat ID.
    Now accepts a pathlib.Path object.
    """
    params = {"chat_id": SEND_CHAT_ID, "caption": caption}
    try:
        with image_path.open("rb") as photo:
            files = {"photo": photo}
            response = requests.post(API_URL + "sendPhoto", data=params, files=files)
            response.raise_for_status()
            logger.info(f"Sent photo to {SEND_CHAT_ID}")
    except FileNotFoundError:
        logger.error(f"Error: Photo file not found at {image_path}")
    except requests.exceptions.RequestException as e:
        logger.error(f"Error sending photo to {SEND_CHAT_ID}: {e}")

def send_video(video_path: Path) -> None:
    """
    Sends a video from a local file to the configured chat ID.
    Now accepts a pathlib.Path object.
    """
    params = {"chat_id": SEND_CHAT_ID}
    try:
        with video_path.open("rb") as video:
            files = {"video": video}
            response = requests.post(API_URL + "sendVideo", data=params, files=files)
            response.raise_for_status()
            logger.info(f"Sent video to {SEND_CHAT_ID}")
    except FileNotFoundError:
        logger.error(f"Error: Video file not found at {video_path}")
    except requests.exceptions.RequestException as e:
        logger.error(f"Error sending video to {SEND_CHAT_ID}: {e}")
        
# Performs long polling https://core.telegram.org/bots/api#getupdates
# 10 minutes should be enough to not flood the server with requests 
def get_updates(offset=None, timeout=600):
    """
    Fetches updates from the Telegram API.
    Uses 'long polling' with a timeout to wait for new messages.
    """
    params = {"timeout": timeout, "offset": offset}
    try:
        logger.info(f"Polling for updates with offset {offset} and timeout {timeout}s...")
        response = requests.get(API_URL + "getUpdates", params=params, timeout=timeout + 5)
        response.raise_for_status()  # Raises an exception for bad status codes
        return response.json()["result"]
    except requests.exceptions.RequestException as e:
        logger.error(f"Error fetching updates: {e}")
        return []

# Starts a loop waiting for command, whenever a command arrives it places it in a queue
def wait_commands(queue, allowed_commands):
    
    # Log some debug: 
    logger.warning(f"Whitelisted chat ids: {WL_CHAT_ID}")
    logger.info(f"Whitelisted user ids: {WL_USER_ID}")
    logger.info(f"Messages will be sent to this id: {SEND_CHAT_ID}")
    logger.info(f"Debug will be sent to this id: {DEBUG_CHAT_ID}")
    logger.warning("wait_commands: THIS FUNCTION IS NOT THREAD SAFE! PLEASE DON'T CALL IT FROM MULTIPLE THREADS")
    #if not TG_TOKEN or not WL_CHAT_ID:
    #    logger.error("TG_TOKEN or CHAT_ID environment variables are not set.")
    #    return
    # Read the last update ID from the file to resume from where we left off
    try:
        last_update_id = read_last_update_id()
        logger.info("Bot started and is polling for updates...")
    except Exception as e:
        # Catch the exception and log it
        logger.error(f"An error occurred in the thread: {e}", exc_info=True)
    
    updates = get_updates(offset=last_update_id,timeout=1)

    logger.info(f"Found {len(updates)} since last time, discarding them.. ")
    
    if len(updates) > 0:
        last_update_id = updates[-1]["update_id"] + 1
        logger.info(f"Updating the last update with {last_update_id}")
        write_last_update_id(last_update_id)

    while True:
        try:
            updates = get_updates(offset=last_update_id)

            for update in updates:
                # Get the last update ID to continue from there
                last_update_id = update["update_id"] + 1
                # Write the new last_update_id to the file immediately after processing
                write_last_update_id(last_update_id)

                # Check if the update is a message and a command
                if "message" in update and "text" in update["message"]:
                    message = update["message"]
                    chat_id = message["chat"]["id"]
                    user_id = message["from"]["id"]
                    user_first_name = message["from"]["first_name"]

                    # Filter by allowed chat IDs
                    if str(chat_id) not in WL_CHAT_ID:
                        logger.warning(f"Message from unauthorized chat ID: {chat_id}")
                        send_message(DEBUG_CHAT_ID, f"Message from {user_first_name} in {chat_id} was blocked")
                        continue

                    if str(user_id) not in WL_USER_ID:
                        logger.warning(f"Message from unauthorized user ID: {user_id}")
                        send_message(DEBUG_CHAT_ID, f"Message from {user_first_name} w/ user {user_id} was blocked")
                        continue

                    # Check text only now that we have validated the message is coming from known source
                    text = message["text"]

                    # Check if the text is a command (starts with '/')
                    if text.startswith("/"):
                        split = text.strip(" ").split(" ")
                        
                        command = split[0].lower()

                        if len(split) > 1:
                            payload = split[1]
                        else:
                            payload = ""
                        
                        if command in allowed_commands:
                            logger.info(f"Setting command: {command} with payload {payload}")
                            queue.put( {"command":command,"payload":payload })
            
            # Simple sleep to prevent excessive API calls
            time.sleep(2)

        except Exception as e:
            logger.error(f"An unexpected error occurred: {e}")
            time.sleep(5) # Wait before retrying


if __name__ == "__main__": 
    from queue import Queue
    
    logger.setLevel(logging.DEBUG)
    if not logger.handlers:
        ch = logging.StreamHandler()
        ch.setLevel(logging.DEBUG)
        formatter = logging.Formatter("%(asctime)s [%(levelname)s] %(name)s: %(message)s")
        ch.setFormatter(formatter)
        logger.addHandler(ch)

    queue = Queue()
    ALLOWED_COMMANDS = ["/video","/up","/down"]
    wait_commands(queue,ALLOWED_COMMANDS)




























