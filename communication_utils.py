####### DESIGN PATTERNS ####################################################################

# This is an attempt to abstract the communication abilities of the tarsier-job script
# the idea is that now we talk through telegram but it doesn't HAVE to be the only option
# it was just the most convenient. 

# To abstract it we need to define a set of operations that we need to support, in particular:
# - send text
# - send message 
# - send image 
# - poll for commands and respond to them 

# The user would then create an object CommHandler and attach a backend for instance TG 
# however for now I will make a hardcoded Telegram implementation, while keeping the functions
# general enough so if I make them more generic in the future the tarsier-job.py won't change. 

####### SECURITY CONCERNS ####################################################################

# The way telegram works is that the bot is accessible by anyone and we don't want to send 
# the videos to a random person that queries them, I made a quick assessment of the security 
# implications of this approach and I deem it safe. Here is a quick summary: 

# The primary conclusion was that the Telegram server handles a significant amount of the 
# security work for you. It sanitizes the incoming requests, so common vulnerabilities like 
# malicious JSON payloads or direct attempts to exploit server-side libraries like curl or 
# requests via the API's structure are not a significant concern. 
# The server acts as a strong barrier, only forwarding valid, structured data to your bot.

# The main point of vulnerability is in the user-provided text field, as this is the only 
# part of the message that Telegram passes to your bot unchanged. The danger isn't from the 
# Telegram platform itself, but from how your bot's code processes that text. 
# For example, if your bot takes the user's message and directly executes it as a shell command, 
# or uses it to build a database query without proper sanitization, that's where an attacker 
# can exploit a vulnerability.

# Therefore, the key to a secure bot is to assume that all user input in the text field is 
# potentially malicious. The best defense is to implement robust validation and sanitization 
# on your end before you use the text for any purpose.

# To avoid bad texts we can filter from chat id and user id, which are whitelisted numbers from 
# my and other allowed telegram groups and accounts. The assumption here is that a malicious user 
# cannot spoof these IDs because they are generated by the telegram server. 

######### THREAD SAFETY CONCERNS ###########################################################

# This library only contains functions and it's stateless so it doesn't really matter if the
# functions are called from multiple threads. Actually there is one element that keeps a state
# which is the last id for the updates. 
# If multiple threads use the wait function the ID will be de-synch between all of them, so 
# yes don't use that function from multiple threads. The other functions are fine. 


import os
import pathlib
from pathlib import Path
import requests
from urllib.parse import quote
from datetime import datetime
import logging
import time

# Wokaround so that this stateless module uses the same logger as the main function that imports this 
# module. 
logging.basicConfig(level=logging.INFO, format='[%(asctime)s] [%(threadName)s] %(message)s', datefmt='%Y-%m-%d %H:%M:%S')

TG_TOKEN = os.getenv("TG_TOKEN")  # token from env

# The base URL for the Telegram Bot API
API_URL = f"https://api.telegram.org/bot{TG_TOKEN}/"

#When parsing the request, allow only if it comes from the whitelist
WL_CHAT_ID = os.getenv("WL_CHAT_ID", "").split(",")  # allow multiple IDs, comma separated
WL_USER_ID = os.getenv("WL_USER_ID", "").split(",")  # allow multiple IDs, comma separated

# When sending a message, send it only to a specific chat defined by another env variable
SEND_CHAT_ID  = os.getenv("SEND_CHAT_ID")
DEBUG_CHAT_ID = os.getenv("DEBUG_CHAT_ID")

def send_text(text: str) -> None:
    """
    Sends a text message to the configured chat ID.
    """
    params = {"chat_id": SEND_CHAT_ID, "text": text}
    try:
        response = requests.post(API_URL + "sendMessage", data=params)
        response.raise_for_status()
        logging.info(f"Sent text message to {SEND_CHAT_ID}")
    except requests.exceptions.RequestException as e:
        logging.error(f"Error sending text message to {SEND_CHAT_ID}: {e}")

def send_photo(image_path: Path, caption: str = "") -> None:
    """
    Sends a photo from a local file to the configured chat ID.
    Now accepts a pathlib.Path object.
    """
    params = {"chat_id": SEND_CHAT_ID, "caption": caption}
    try:
        with image_path.open("rb") as photo:
            files = {"photo": photo}
            response = requests.post(API_URL + "sendPhoto", data=params, files=files)
            response.raise_for_status()
            logging.info(f"Sent photo {image_path.as_posix()} to {SEND_CHAT_ID}")
    except FileNotFoundError:
        logging.error(f"Error: Photo file not found at {image_path}")
    except requests.exceptions.RequestException as e:
        logging.error(f"Error sending photo to {SEND_CHAT_ID}: {e}")

def send_video(video_path: Path) -> None:
    """
    Sends a video from a local file to the configured chat ID.
    Now accepts a pathlib.Path object.
    """
    params = {"chat_id": SEND_CHAT_ID}
    try:
        with video_path.open("rb") as video:
            files = {"video": video}
            response = requests.post(API_URL + "sendVideo", data=params, files=files)
            response.raise_for_status()
            logging.info(f"Sent video {video_path.as_posix()} to {SEND_CHAT_ID}")
    except FileNotFoundError:
        logging.error(f"Error: Video file not found at {video_path}")
    except requests.exceptions.RequestException as e:
        logging.error(f"Error sending video to {SEND_CHAT_ID}: {e}")
        
def send_video_as_file(video_path: Path) -> None:
    """
    Sends a local video file as a document to the configured chat ID.
    This keeps its original aspect and skips Telegram's media preprocessing.
    """
    params = {"chat_id": SEND_CHAT_ID}
    try:
        with video_path.open("rb") as video:
            files = {"document": video}
            response = requests.post(API_URL + "sendDocument", data=params, files=files)
            response.raise_for_status()
            logging.info(f"Sent video as file {video_path.as_posix()} to {SEND_CHAT_ID}")
    except FileNotFoundError:
        logging.error(f"Error: Video file not found at {video_path}")
    except requests.exceptions.RequestException as e:
        logging.error(f"Error sending video file to {SEND_CHAT_ID}: {e}")
    
# Performs long polling https://core.telegram.org/bots/api#getupdates
# 10 minutes should be enough to not flood the server with requests 
def get_updates(offset=None, timeout=600):
    """
    Fetches updates from the Telegram API.
    Uses 'long polling' with a timeout to wait for new messages.
    """
    params = {"timeout": timeout, "offset": offset}
    try:
        logging.info(f"Polling for updates with offset {offset} and timeout {timeout}s...")
        response = requests.get(API_URL + "getUpdates", params=params, timeout=timeout + 5)
        response.raise_for_status()  # Raises an exception for bad status codes
        return response.json()["result"]
    except requests.exceptions.RequestException as e:
        logging.error(f"Error fetching updates: {e}")
        return []

# Starts a loop waiting for command, whenever a command arrives it places it in a queue
def wait_commands(queue, allowed_commands):
    
    # Log some debug: 
    logging.warning(f"Whitelisted chat ids: {WL_CHAT_ID}")
    logging.info(f"Whitelisted user ids: {WL_USER_ID}")
    logging.info(f"Messages will be sent to this id: {SEND_CHAT_ID}")
    logging.info(f"Debug will be sent to this id: {DEBUG_CHAT_ID}")

    send_text("Qualcuno ha attaccato la spina!")
    
    # Get all the updates that were sent when the program was offline... and discard them automatically. 
    updates = get_updates(offset=None,timeout=1)

    logging.info(f"Found {len(updates)} while bot was offline, discarding all of them.. ")
    
    if len(updates) > 0:
        last_update_id = updates[-1]["update_id"] + 1
        logging.info(f"Updating the last update with {last_update_id}")
    else:
        last_update_id = None

    while True:
        try:
            updates = get_updates(offset=last_update_id)

            for update in updates:
                # Get the last update ID to continue from there
                last_update_id = update["update_id"] + 1

                # Check if the update is a message and a command
                if "message" in update and "text" in update["message"]:
                    message = update["message"]
                    chat_id = message["chat"]["id"]
                    user_id = message["from"]["id"]
                    user_first_name = message["from"]["first_name"]

                    # Filter by allowed chat IDs
                    if str(chat_id) not in WL_CHAT_ID:
                        logging.warning(f"Message from unauthorized chat ID: {chat_id}")
                        send_message(DEBUG_CHAT_ID, f"Message from {user_first_name} in {chat_id} was blocked")
                        continue

                    if str(user_id) not in WL_USER_ID:
                        logging.warning(f"Message from unauthorized user ID: {user_id}")
                        send_message(DEBUG_CHAT_ID, f"Message from {user_first_name} w/ user {user_id} was blocked")
                        continue

                    # Check text only now that we have validated the message is coming from known source
                    text = message["text"]

                    # Check if the text is a command (starts with '/')
                    if text.startswith("/"):
                        split = text.strip(" ").split(" ")
                        
                        command = split[0].lower()

                        if len(split) > 1:
                            payload = split[1]
                        else:
                            payload = ""
                        
                        if command in allowed_commands:
                            logging.info(f"Setting command: {command} with payload {payload}")
                            queue.put( {"command":command,"payload":payload })
            
            # Simple sleep to prevent excessive API calls
            time.sleep(2)

        except Exception as e:
            logging.error(f"An unexpected error occurred: {e}")
            time.sleep(5) # Wait before retrying


if __name__ == "__main__": 


    # This is only for testing
    from queue import Queue
    
    logging.setLevel(logging.DEBUG)
    if not logging.handlers:
        ch = logging.StreamHandler()
        ch.setLevel(logging.DEBUG)
        formatter = logging.Formatter("%(asctime)s [%(levelname)s] %(name)s: %(message)s")
        ch.setFormatter(formatter)
        logging.addHandler(ch)

    queue = Queue()
    ALLOWED_COMMANDS = ["/video","/up","/down","/now"]
    wait_commands(queue,ALLOWED_COMMANDS)




























